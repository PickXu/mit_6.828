1. Panic on double acquire by the same CPU
2. The kernel panicked because, after the cpu acquires the lock, another IDE interrupt comes and tries to acquire the same lock by calling acquire(), which cause the kernel panic.
3. The kernel does not panic because the ide interrupt is fired frequently and the interrupt handler always try to acquire the ide lock, which can conflict iderw operations if the interrupt is enabled. As for file_table_lock, there is no interrupt whose handler will try to acquire the file table lock. So the panic will not happen. The only possibility that a panic happens is that the sti() and cli() in file_table_lock() coincide in between the acquire() and release() in iderw().
4. If clearing lk->pcs[0] and lk->cpu after clearing lk->locked, after lk-locked is cleared, there is chance that the same processor is switched to another task before clearing lk->pcs[0] and lk->cpu, and the new task may try to acquire the same lock, which will panic the kernel as the kernel thinks it still holds the lock.
